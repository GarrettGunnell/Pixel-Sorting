#pragma kernel CS_CreateMask
#pragma kernel CS_TestSelectionSort
#pragma kernel CS_TestBitonicSort

float _LowThreshold, _HighThreshold;

int _BufferWidth, _BufferHeight;

RWTexture2D<float> _Mask;
RWTexture2D<float4> _ColorBuffer;
RWTexture2D<float4> _SortedBuffer;

RWStructuredBuffer<int> _NumberBuffer;

float luminance(float3 color) {
    return dot(color, float3(0.299f, 0.587f, 0.114f));
}

[numthreads(8,8,1)]
void CS_CreateMask(uint3 id : SV_DispatchThreadID) {
    float4 col = saturate(_ColorBuffer[id.xy]);
    float l = luminance(col.rgb);

    float result = 1.0f;
    if (l < _LowThreshold || _HighThreshold < l)
        result = 0.0f;
    
    _Mask[id.xy] = result;
}

// Selection Sort, so performant!!!!
[numthreads(1,1,1)]
void CS_TestSelectionSort(uint3 id : SV_DISPATCHTHREADID) {
    int n = 16;

    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (_NumberBuffer[j] < _NumberBuffer[minIndex])
                minIndex = j;
        }

        int temp = _NumberBuffer[minIndex];
        _NumberBuffer[minIndex] = _NumberBuffer[i];
        _NumberBuffer[i] = temp;
    }
}

//Implementation largely referenced from https://poniesandlight.co.uk/reflect/bitonic_merge_sort/ but without the bugs
#define BITONIC_ELEMENTS 512

groupshared float3 gs_ColorCache[BITONIC_ELEMENTS];

float comparisonValue(float3 col) {
    return luminance(col);
}

void compareAndSwap(int2 idx) {
    if (comparisonValue(gs_ColorCache[idx.x]) <= comparisonValue(gs_ColorCache[idx.y])) {
        float3 temp = gs_ColorCache[idx.x];
        gs_ColorCache[idx.x] = gs_ColorCache[idx.y];
        gs_ColorCache[idx.y] = temp;
    }
}

void flip(int h, uint t) {
    int q = ((2 * t) / h) * h;
    uint half_h = h / 2;
    int2 indices = q + int2(t % half_h, h - (t % half_h) - 1);
    compareAndSwap(indices);
}

void disperse(int h, uint t) {
    int q = ((2 * t) / h) * h;
    uint half_h = h / 2;
    int2 indices = q + int2(t % half_h, (t % half_h) + half_h);
    compareAndSwap(indices);
}

[numthreads(BITONIC_ELEMENTS / 2, 1, 1)]
void CS_TestBitonicSort(uint3 id : SV_DISPATCHTHREADID) {
    uint2 t = id.xy;

    gs_ColorCache[t.x * 2] = _ColorBuffer[uint2(t.x * 2, t.y)].rgb;
    gs_ColorCache[t.x * 2 + 1] = _ColorBuffer[uint2(t.x * 2 + 1, t.y)].rgb;

    uint n = BITONIC_ELEMENTS;
    
    [unroll]
    for (uint h = 2; h <= n; h *= 2) {
        GroupMemoryBarrierWithGroupSync();
        flip(h, t.x);
        
        [unroll]
        for (uint hh = h / 2; hh > 1; hh /= 2) {
            GroupMemoryBarrierWithGroupSync();
            disperse(hh, t.x);
        }
    }
    
    _SortedBuffer[uint2(t.x * 2, t.y)] = float4(gs_ColorCache[t.x * 2], 1.0f);
    _SortedBuffer[uint2(t.x * 2 + 1, t.y)] = float4(gs_ColorCache[t.x * 2 + 1], 1.0f);
}