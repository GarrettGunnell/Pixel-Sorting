#pragma kernel CS_CreateMask
#pragma kernel CS_TestSelectionSort
#pragma kernel CS_TestBitonicSort
#pragma kernel CS_TestCustomSort
#pragma kernel CS_TestCustomSortOnImage
#pragma kernel CS_ClearBuffer
#pragma kernel CS_IdentifySpans
#pragma kernel CS_VisualizeSpans
#pragma kernel CS_PixelSort
#pragma kernel CS_Composite

float _LowThreshold, _HighThreshold;

uint _BufferWidth, _BufferHeight;

int _ReverseSorting;

RWTexture2D<float> _Mask;
RWTexture2D<float4> _ColorBuffer;
RWTexture2D<float4> _SortedBuffer;
RWTexture2D<float> _SpanBuffer;

RWTexture2D<float4> _ClearBuffer;

RWStructuredBuffer<uint> _NumberBuffer;
RWStructuredBuffer<uint> _SortedNumberBuffer;

float luminance(float3 color) {
    return dot(color, float3(0.299f, 0.587f, 0.114f));
}

[numthreads(8,8,1)]
void CS_CreateMask(uint3 id : SV_DispatchThreadID) {
    float4 col = saturate(_ColorBuffer[id.xy]);
    float l = luminance(col.rgb);

    int result = 1;
    if (l < _LowThreshold || _HighThreshold < l)
        result = 0;
    
    _Mask[id.xy] = result;
}

// Selection Sort, so performant!!!!
[numthreads(1,1,1)]
void CS_TestSelectionSort(uint3 id : SV_DISPATCHTHREADID) {
    int n = 16;

    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (_NumberBuffer[j] < _NumberBuffer[minIndex])
                minIndex = j;
        }

        int temp = _NumberBuffer[minIndex];
        _NumberBuffer[minIndex] = _NumberBuffer[i];
        _NumberBuffer[i] = temp;
    }
}

//Implementation largely referenced from https://poniesandlight.co.uk/reflect/bitonic_merge_sort/ but without the bugs
#define BITONIC_ELEMENTS 512

groupshared float3 gs_ColorCache[BITONIC_ELEMENTS];

float comparisonValue(float3 col) {
    return luminance(col);
}

void compareAndSwap(int2 idx) {
    float c1 = comparisonValue(gs_ColorCache[idx.x]);
    float c2 = comparisonValue(gs_ColorCache[idx.y]);

    bool result = _ReverseSorting ? c1 >= c2 : c1 <= c2;

    if (result) {
        float3 temp = gs_ColorCache[idx.x];
        gs_ColorCache[idx.x] = gs_ColorCache[idx.y];
        gs_ColorCache[idx.y] = temp;
    }
}

void flip(int h, uint t) {
    int q = ((2 * t) / h) * h;
    uint half_h = h / 2;
    int2 indices = q + int2(t % half_h, h - (t % half_h) - 1);
    compareAndSwap(indices);
}

void disperse(int h, uint t) {
    int q = ((2 * t) / h) * h;
    uint half_h = h / 2;
    int2 indices = q + int2(t % half_h, (t % half_h) + half_h);
    compareAndSwap(indices);
}

[numthreads(BITONIC_ELEMENTS / 2, 1, 1)]
void CS_TestBitonicSort(uint3 id : SV_DISPATCHTHREADID) {
    uint2 t = id.xy;

    if (t.x * 2 + 1 < _BufferWidth) {
        gs_ColorCache[t.x * 2] = _ColorBuffer[uint2(t.x * 2, t.y)].rgb;
        gs_ColorCache[t.x * 2 + 1] = _ColorBuffer[uint2(t.x * 2 + 1, t.y)].rgb;
    } else {
        gs_ColorCache[t.x * 2] = _ReverseSorting ? 1.0f : 0.0f;
        gs_ColorCache[t.x * 2 + 1] = _ReverseSorting ? 1.0f : 0.0f;
    }


    uint n = BITONIC_ELEMENTS;
    
    [unroll]
    for (uint h = 2; h <= n; h *= 2) {
        GroupMemoryBarrierWithGroupSync();
        flip(h, t.x);
        
        [unroll]
        for (uint hh = h / 2; hh > 1; hh /= 2) {
            GroupMemoryBarrierWithGroupSync();
            disperse(hh, t.x);
        }
    }
    
    _SortedBuffer[uint2(t.x * 2, t.y)] = float4(gs_ColorCache[t.x * 2], 1.0f);
    _SortedBuffer[uint2(t.x * 2 + 1, t.y)] = float4(gs_ColorCache[t.x * 2 + 1], 1.0f);
}

// I'm sure this has a name somewhere but I made up this sorting method to minimize writes to O(n) while reads stay at a constant O(n^2)
[numthreads(1, 1, 1)]
void CS_TestCustomSort(uint3 id : SV_DISPATCHTHREADID) {
    uint minNumber = 100000;
    uint prevMinNumber = 0;

    for (int i = 0; i < 16; ++i) {
        for (int j = 0; j < 16; ++j) {
            uint n = _NumberBuffer[j];

            if (n < minNumber && prevMinNumber < n) {
                minNumber = n;
            }
        }

        _SortedNumberBuffer[i] = minNumber;
        prevMinNumber = minNumber;
        minNumber = 100000;
    }
}

#define CUSTOM_SORT_ELEMENTS 512

groupshared float3 gs_CustomColorCache[CUSTOM_SORT_ELEMENTS];

[numthreads(1, 1, 1)]
void CS_TestCustomSortOnImage(uint3 id : SV_DISPATCHTHREADID) {
    float3 minColor = 0.0f;
    float minValue = 100000;
    float prevMinValue = 0;

    for (int k = 0; k < CUSTOM_SORT_ELEMENTS; ++k) {
        gs_CustomColorCache[k] = _ColorBuffer[uint2(k, id.y)].rgb;
    }

    for (int i = 0; i < CUSTOM_SORT_ELEMENTS; ++i) {
        for (int j = 0; j < CUSTOM_SORT_ELEMENTS; ++j) {
            float3 c = gs_CustomColorCache[j];

            float l = luminance(c);

            if (l < minValue && prevMinValue < l) {
                minValue = l;
                minColor = c;
            }
        }

        _SortedBuffer[uint2(i, id.y)] = float4(minColor, 1.0f);
        prevMinValue = minValue;
        minValue = 100000;
    }
}

[numthreads(8,8,1)]
void CS_ClearBuffer(uint3 id : SV_DISPATCHTHREADID) {
    _ClearBuffer[id.xy] = 0;
}

[numthreads(1, 1, 1)]
void CS_IdentifySpans(uint3 id : SV_DISPATCHTHREADID) {
    uint x = 0;
    int spanStartIndex = 0;
    int spanLength = 0;

    while (x < _BufferWidth) {
        uint2 idx = uint2(x, id.y);

        int mask = _Mask[idx];
        x++;

        if (mask != 0) {
            spanLength++;
        } else {
            _SpanBuffer[uint2(spanStartIndex, id.y)] = spanLength;
            spanStartIndex = x;
            spanLength = 0;
        }
    }

    if (spanLength != 0) {
        _SpanBuffer[uint2(spanStartIndex, id.y)] = spanLength;
    }
}

float hash(uint n) {
    // integer hash copied from Hugo Elias
	n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

[numthreads(8, 8, 1)]
void CS_VisualizeSpans(uint3 id : SV_DISPATCHTHREADID) {
    int spanLength = _SpanBuffer[id.xy];

    if (spanLength >= 1) {
        uint seed = id.x + 512 * id.y + 512 * 512;
        float4 c = float4(hash(seed), hash(seed * 2), hash(seed * 3), 1.0f);

        for (int i = 0; i < spanLength; ++i) {
            uint2 idx = uint2(id.x + i, id.y);
            _SortedBuffer[idx] = c;
        }
    }
}

groupshared float3 gs_PixelSortCache[512];

[numthreads(1, 1, 1)]
void CS_PixelSort(uint3 id : SV_DISPATCHTHREADID) {
    int spanLength = _SpanBuffer[id.xy];

    if (spanLength >= 1) {
        float3 currColor = 0.0f;
        float currValue = 100000;
        float prevValue = 0;

        for (int k = 0; k < spanLength; ++k) {
            gs_CustomColorCache[k] = _ColorBuffer[uint2(id.x + k, id.y)].rgb;
        }

        for (int i = 0; i < spanLength; ++i) {
            for (int j = 0; j < spanLength; ++j) {
                float3 c = gs_CustomColorCache[j].rgb;

                float l = luminance(c);

                if (l < currValue && prevValue < l) {
                    currValue = l;
                    currColor = c;
                }
            }

            uint2 idx = uint2(id.x + i, id.y);

            if (_ReverseSorting)
                idx = uint2(id.x + (spanLength - i - 1), id.y);

            _SortedBuffer[idx] = float4(currColor, 1.0f);
            prevValue = currValue;
            currValue = 100000;
        }
    }
}

[numthreads(8, 8, 1)]
void CS_Composite(uint3 id : SV_DISPATCHTHREADID) {
    if (_Mask[id.xy] == 0) {
        _SortedBuffer[id.xy] = _ColorBuffer[id.xy];
    }
}